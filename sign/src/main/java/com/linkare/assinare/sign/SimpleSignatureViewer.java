package com.linkare.assinare.sign;

import static java.util.Collections.EMPTY_LIST;

import java.awt.Color;
import java.awt.Component;
import java.awt.Window;
import java.awt.event.WindowEvent;
import java.security.cert.CertificateExpiredException;
import java.security.cert.CertificateNotYetValidException;
import java.security.cert.X509Certificate;
import java.util.Date;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.DefaultListCellRenderer;
import javax.swing.ImageIcon;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JList;
import javax.swing.ListCellRenderer;
import javax.swing.ListModel;
import javax.swing.SwingUtilities;
import javax.swing.SwingWorker;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;

import com.linkare.assinare.commons.ui.SignatureStage;

/**
 *
 * @author bnazare
 * @param <D> the type of the data displayed
 * @param <K> the type of signature fields
 */
public class SimpleSignatureViewer<D, K extends SignatureFields> extends javax.swing.JDialog implements SignatureViewer<D, K> {

    private static final long serialVersionUID = -4333597589127470862L;
    private static final Logger LOG = Logger.getLogger(SimpleSignatureViewer.class.getName());

    private final K baseSigOpts;
    private final KeySupplier signingKeysSupplier;
    private final CompletableFuture<K> sigFieldsFuture = new CompletableFuture<>();
    private final CompletableFuture<SigningKey> sigKeyFuture = new CompletableFuture<>();
    private final Future<List<SigningKey>> sigKeysFuture;

    /**
     * Creates new form SimplePdfSignatureViewer
     *
     * @param modal
     * @param sigOptions
     * @param signingKeysSupplier
     */
    public SimpleSignatureViewer(boolean modal, K sigOptions, KeySupplier signingKeysSupplier) {
        super((Window) null, modal ? JDialog.DEFAULT_MODALITY_TYPE : ModalityType.MODELESS);
        this.baseSigOpts = sigOptions;
        this.signingKeysSupplier = signingKeysSupplier;
        initComponents();
        sigKeyComboBox.getModel().addListDataListener(new SigningKeyListDataListener());

        setGlassPane(blockerPanel);
        getGlassPane().setVisible(true);

        ExecutorService executor = Executors.newSingleThreadExecutor();
        this.sigKeysFuture = executor.submit(() -> this.signingKeysSupplier.getKeys());
        executor.shutdown();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        blockerPanel = new com.linkare.assinare.sign.swing.BlockerPanel();
        deckCards = new com.linkare.assinare.sign.swing.DeckCardsPanel();
        sigKeyComboBox = new javax.swing.JComboBox<>();
        reloadButton = new javax.swing.JButton();

        blockerPanel.setName("blockerPanel"); // NOI18N

        setTitle("ASSINARE");
        setIconImage(new ImageIcon(getClass().getResource("/icons/assinareIconHeader.png")).getImage());
        setName("Form"); // NOI18N
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        deckCards.setEnabled(false);
        deckCards.setName("deckCards"); // NOI18N
        deckCards.addCancelListener(new com.linkare.assinare.sign.swing.CancelListener() {
            public void actionCanceled(java.awt.event.ActionEvent evt) {
                deckCardsActionCanceled(evt);
            }
        });
        deckCards.addConfirmListener(new com.linkare.assinare.sign.swing.ConfirmListener() {
            public void actionConfirmed(java.awt.event.ActionEvent evt) {
                deckCardsActionConfirmed(evt);
            }
        });

        sigKeyComboBox.setEnabled(false);
        sigKeyComboBox.setName("sigKeyComboBox"); // NOI18N
        sigKeyComboBox.setRenderer(getSigningKeyRenderer());

        reloadButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/icons/refreshIcon.png"))); // NOI18N
        reloadButton.setName("reloadButton"); // NOI18N
        reloadButton.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/icons/refreshIconOver.png"))); // NOI18N
        reloadButton.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/icons/refreshIconOver.png"))); // NOI18N
        reloadButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                reloadButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(0, 432, Short.MAX_VALUE)
                        .addComponent(deckCards, javax.swing.GroupLayout.PREFERRED_SIZE, 226, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(sigKeyComboBox, 0, 600, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(reloadButton)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(sigKeyComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(reloadButton, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(deckCards, javax.swing.GroupLayout.PREFERRED_SIZE, 96, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void deckCardsActionCanceled(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deckCardsActionCanceled
//        state = SignatureViewerState.SIGN_CANCELED;
        sigFieldsFuture.cancel(false);
        sigKeyFuture.cancel(false);
    }//GEN-LAST:event_deckCardsActionCanceled

    private void deckCardsActionConfirmed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deckCardsActionConfirmed
//        state = SignatureViewerState.SIGN_CONFIRMED;
//        sigFieldsFuture.complete(collectSignatureFields());
        sigFieldsFuture.complete(baseSigOpts);
        sigKeyFuture.complete((SigningKey) sigKeyComboBox.getSelectedItem());
    }//GEN-LAST:event_deckCardsActionConfirmed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        if (!sigFieldsFuture.isDone()) {
            sigFieldsFuture.cancel(false);
        }
    }//GEN-LAST:event_formWindowClosing

    private void reloadButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_reloadButtonActionPerformed
        getGlassPane().setVisible(true);

        replaceElements(sigKeyComboBox, EMPTY_LIST);

        new SigningKeysWorker().execute();
    }//GEN-LAST:event_reloadButtonActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private com.linkare.assinare.sign.swing.BlockerPanel blockerPanel;
    private com.linkare.assinare.sign.swing.DeckCardsPanel deckCards;
    private javax.swing.JButton reloadButton;
    private javax.swing.JComboBox<com.linkare.assinare.sign.SigningKey> sigKeyComboBox;
    // End of variables declaration//GEN-END:variables

    @Override
    public void dataReady(D data) {
        List<SigningKey> tmpSigKeys;
        try {
            tmpSigKeys = sigKeysFuture.get();
        } catch (InterruptedException | ExecutionException ex) {
            LOG.log(Level.SEVERE, null, ex);
            tmpSigKeys = EMPTY_LIST;
        }

        // we need a final variable to pass to the lambda function below
        final List<SigningKey> sigKeys = tmpSigKeys;

        SwingUtilities.invokeLater(() -> {
            replaceElements(sigKeyComboBox, sigKeys);

            getGlassPane().setVisible(false);

            if (sigKeyComboBox.getItemCount() > 0) {
                sigKeyComboBox.requestFocusInWindow();
            } else {
                reloadButton.requestFocusInWindow();
            }
        });
    }

    private static void replaceElements(JComboBox comboBox, List<SigningKey> signingKeys) {
        comboBox.removeAllItems();
        signingKeys.forEach(sigKey -> {
            comboBox.addItem(sigKey);
        });
    }

    @Override
    public Future<K> getSignatureFields() {
        return sigFieldsFuture;
    }

    @Override
    public Future<SigningKey> getSigningKey() {
        return sigKeyFuture;
    }

    @Override
    public void publicPublish(final SignatureStage... chunks) {
        SignatureStage latestStage = chunks[chunks.length - 1];

        if (!SwingUtilities.isEventDispatchThread()) {
            SwingUtilities.invokeLater(() -> {
                deckCards.changePanel(latestStage);
            });
        }
    }

    @Override
    public void signatureDone() {
        closeWindow();
    }

    private void closeWindow() {
        dispatchEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));
    }

    private ListCellRenderer<Object> getSigningKeyRenderer() {
        return new SigningKeyListCellRenderer();

    }

    private class SigningKeyListDataListener implements ListDataListener {

        @Override
        public void intervalAdded(ListDataEvent e) {
            if (((ListModel) e.getSource()).getSize() > 0) {
                sigKeyComboBox.setEnabled(true);
                deckCards.setEnabled(true);
            }
        }

        @Override
        public void intervalRemoved(ListDataEvent e) {
            if (((ListModel) e.getSource()).getSize() <= 0) {
                sigKeyComboBox.setEnabled(false);
                deckCards.setEnabled(false);
            }
        }

        @Override
        public void contentsChanged(ListDataEvent e) {
            // This code will likey never run, but just to be safe
            if (((ListModel) e.getSource()).getSize() > 0) {
                sigKeyComboBox.setEnabled(true);
                deckCards.setEnabled(true);
            } else {
                sigKeyComboBox.setEnabled(false);
                deckCards.setEnabled(false);
            }
        }
    }

    private static class SigningKeyListCellRenderer extends DefaultListCellRenderer {

        private static final long serialVersionUID = 893536436048939053L;

        private static final Color ERROR_COLOR = new Color(139, 0, 0);
        private static final Color EXPIRED_CERT_COLOR = new Color(191, 144, 0);

        @Override
        public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
            boolean expired = false;
            boolean error = false;
            Object newValue;

            if (value instanceof SigningKey) {
                SigningKey key = (SigningKey) value;
                String stringValue;
                try {
                    // FIXME: check nulls
                    X509Certificate cert = key.getCertificate();
                    X500NameParser subject = new X500NameParser(cert.getSubjectX500Principal());
                    String subjectCN = subject.getCommonName();

                    String textValue;
                    if (cert.getSubjectX500Principal().equals(cert.getIssuerX500Principal())) { // if self-signed
                        textValue = subjectCN + " <auto-assinado>";
                    } else {
                        X500NameParser issuer = new X500NameParser(cert.getIssuerX500Principal());
                        String issuerCN = issuer.getCommonName();
                        textValue = subjectCN + ", " + issuerCN;
                    }

                    expired = checkExpired(cert);
                    if (expired) {
                        stringValue = "<expirado> " + textValue;
                    } else {
                        stringValue = textValue;
                    }
                } catch (RuntimeException ex) {
                    // this shouldn't be a problem but we do it to prevent any unexcepted
                    // issues with the certificates from breaking the rest of the interface
                    LOG.log(Level.SEVERE, null, ex);
                    stringValue = "<certificado com erro>";
                    error = true;
                }
                newValue = stringValue;
            } else {
                newValue = value;
            }

            Component comp = super.getListCellRendererComponent(list, newValue, index, isSelected, cellHasFocus);
            if (error) {
                comp.setForeground(ERROR_COLOR);
            } else if (expired) {
                comp.setForeground(EXPIRED_CERT_COLOR);
            }

            return comp;
        }

        private boolean checkExpired(X509Certificate cert) {
            try {
                cert.checkValidity(new Date());
                return false;
            } catch (CertificateExpiredException | CertificateNotYetValidException e) {
                return true;
            }
        }

    }

    private class SigningKeysWorker extends SwingWorker<Void, SigningKey> {

        @Override
        protected Void doInBackground() {
            publish(signingKeysSupplier.getKeys().toArray(new SigningKey[0]));
            return null;
        }

        @Override
        protected void process(List<SigningKey> chunks) {
            replaceElements(sigKeyComboBox, chunks);
        }

        @Override
        protected void done() {
            getGlassPane().setVisible(false);
        }
    }

}
